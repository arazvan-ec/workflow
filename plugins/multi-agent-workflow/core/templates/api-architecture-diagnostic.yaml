# =============================================================================
# API Architecture Diagnostic Specification Template
# =============================================================================
# Dimensional analysis framework for diagnosing API architecture situations.
# Unlike pattern-matching (detect X -> suggest Y), this spec encodes REASONING
# DIMENSIONS that generate architectural CONSTRAINTS from first principles.
#
# Generated by: /workflows:discover (Step 6c)
# Consumed by:  /workflows:plan (Step 3.1b) and /workflows:review
# Enriched by:  /workflows:compound (dimensional drift detection)
# Location:     openspec/specs/api-architecture-diagnostic.yaml
#
# Philosophy:
#   "The constraint is the reasoning. The pattern is just the fix."
#   Dimensions describe WHAT the architecture IS.
#   Constraints describe WHAT MUST be true given the dimensions.
#   Patterns (in architecture-reference.md) describe HOW to achieve the constraints.
# =============================================================================

diagnostic_version: "1.0"
generated_at: ""                  # ISO 8601 timestamp
generated_by: "discover"          # discover | plan | manual

# =============================================================================
# DIMENSION 1: DATA FLOW DIRECTION
# =============================================================================
# What direction does data move through this API system?
# This determines where transformation boundaries must exist.
data_flow:
  primary: ""
  # Values:
  #   ingress         - External data comes IN to the system (consuming external APIs)
  #   egress          - Internal data goes OUT to consumers (serving API responses)
  #   aggregation     - Multiple external sources combined into domain objects
  #   transformation  - Data restructured between incompatible formats
  #   passthrough     - Data relayed with minimal transformation
  #   bidirectional   - Both ingress and egress are significant
  secondary: []                   # Other flows present (same value set)

  # Detection heuristics (stack-agnostic):
  #   ingress:       HTTP client libs in codebase, external API adapters
  #   egress:        Controllers/handlers serving JSON/XML, serializers
  #   aggregation:   Services combining 3+ data sources into one response
  #   transformation: Mapper/transformer classes, DTO conversions
  #   passthrough:   Proxy routes, gateway patterns, minimal logic
  #   bidirectional: Both HTTP client usage AND controller endpoints present

  evidence: []                    # Files/patterns that determined this value
  # Example:
  # evidence:
  #   - "src/Infrastructure/External/ contains 4 API adapters (ingress)"
  #   - "src/Infrastructure/Controller/ serves 12 endpoints (egress)"

  constraints: []
  # Constraint generation rules:
  #   IF primary in [ingress, aggregation, bidirectional]:
  #     -> "Inbound data MUST cross an abstraction boundary before entering Domain"
  #     -> SOLID: DIP (domain depends on port, not SDK)
  #   IF primary in [egress, bidirectional]:
  #     -> "Outbound data MUST be shaped by Application/Infrastructure, not Domain"
  #     -> SOLID: SRP (domain has no serialization responsibility)
  #   IF primary == aggregation:
  #     -> "Multi-source assembly MUST be coordinated by a dedicated orchestrator"
  #     -> SOLID: SRP (each source behind its own provider)
  #   IF primary == transformation:
  #     -> "Transformation logic MUST be isolated in mapper classes"
  #     -> SOLID: SRP (mapper only maps), OCP (new format = new mapper)
  #   IF primary == passthrough:
  #     -> "Passthrough logic SHOULD NOT add domain coupling"
  #     -> SOLID: DIP (avoid leaking upstream types downstream)

# =============================================================================
# DIMENSION 2: DATA SOURCE TOPOLOGY
# =============================================================================
# Where does this system's data come from?
# This determines isolation boundaries and dependency direction.
data_source_topology:
  value: ""
  # Values:
  #   single_db            - One primary database, no external APIs
  #   multi_db             - Multiple databases (read replicas, sharding, polyglot)
  #   single_external      - One external API/SDK consumed
  #   multi_external       - Multiple external APIs/SDKs consumed
  #   mixed_db_external    - Database(s) + external API(s) combined
  #   event_driven         - Primary data from message queues/event streams
  #   hybrid               - Mix of databases, APIs, and events

  external_sources: []
  # Per-source detail:
  # external_sources:
  #   - name: "Content Management API"
  #     sdk_or_client: "vendor/cms-sdk"
  #     isolation_status: "isolated"    # isolated | partially_wrapped | direct_coupling
  #     port_interface: "src/Domain/Port/ContentProviderInterface.php"
  #     adapter: "src/Infrastructure/External/CmsAdapter.php"

  evidence: []

  constraints: []
  # Constraint generation rules:
  #   IF value in [single_external, multi_external, mixed_db_external, hybrid]:
  #     -> "Each external data source MUST be accessed through a Port (interface in Domain)"
  #     -> "Each external data source MUST have an Adapter (implementation in Infrastructure)"
  #     -> SOLID: DIP (domain depends on abstraction)
  #   IF value in [multi_external, mixed_db_external, hybrid]:
  #     -> "Vendor SDK types MUST NOT appear outside Infrastructure layer"
  #     -> SOLID: DIP (no vendor type leakage)
  #     -> "Each external source MUST have an independent Provider interface"
  #     -> SOLID: ISP (one interface per source, not one fat interface)
  #   IF value == event_driven:
  #     -> "Event consumers MUST translate event payloads to domain types at the boundary"
  #     -> SOLID: DIP, SRP
  #   IF value == single_db:
  #     -> (minimal constraints, standard repository pattern sufficient)

# =============================================================================
# DIMENSION 3: CONSUMER DIVERSITY
# =============================================================================
# Who consumes this system's output?
# This determines serialization and response shaping strategy.
consumer_diversity:
  value: ""
  # Values:
  #   single_consumer         - One client (e.g., one web app)
  #   multi_platform          - Multiple client types (web, mobile, desktop)
  #   inter_service           - Other microservices consume this API
  #   public_api              - Third-party developers consume this API
  #   mixed                   - Combination of the above

  consumers: []
  # Per-consumer detail:
  # consumers:
  #   - name: "Mobile App (iOS/Android)"
  #     format: "compact JSON"
  #     special_needs: "minimal payload, image URLs only"
  #   - name: "Web Dashboard"
  #     format: "full JSON"
  #     special_needs: "includes relationships, pagination"

  evidence: []

  constraints: []
  # Constraint generation rules:
  #   IF value == single_consumer:
  #     -> (minimal constraints, standard DTO serialization sufficient)
  #   IF value in [multi_platform, public_api, mixed]:
  #     -> "Response shape MUST NOT be hardcoded in domain or single serializer"
  #     -> "Each consumer type MUST have its own response transformation"
  #     -> SOLID: SRP (one transformer per consumer), OCP (new consumer = new transformer)
  #     -> "Domain entities MUST NOT contain serialization annotations or logic"
  #     -> SOLID: SRP (entity has no serialization responsibility)
  #   IF value == inter_service:
  #     -> "API contracts MUST be versioned and backward-compatible"
  #     -> SOLID: OCP (new version extends, doesn't break existing)
  #   IF value == public_api:
  #     -> "Response format MUST be documented and stable"
  #     -> "Breaking changes MUST go through versioning"

# =============================================================================
# DIMENSION 4: DEPENDENCY ISOLATION LEVEL
# =============================================================================
# How well are external dependencies isolated from the domain?
# This is the DIP health indicator.
dependency_isolation:
  value: ""
  # Values:
  #   fully_isolated      - All externals behind ports + adapters + mappers
  #   partially_wrapped   - Some adapters exist but ports or mappers are missing
  #   direct_coupling     - External SDKs used directly in Application/Domain
  #   no_externals        - No external dependencies to isolate

  violations: []
  # Per-violation detail:
  # violations:
  #   - location: "src/Application/Service/EditorialService.php:23"
  #     external: "GuzzleHttp\\Client"
  #     layer: "Application"
  #     severity: "high"          # high = in Domain, medium = in Application

  evidence: []

  constraints: []
  # Constraint generation rules:
  #   IF value == direct_coupling:
  #     -> "External dependencies in Domain/Application MUST be replaced with Port interfaces"
  #     -> "Vendor SDK instantiation MUST move to Infrastructure adapters"
  #     -> SOLID: DIP (domain depends on abstraction, not vendor)
  #   IF value == partially_wrapped:
  #     -> "Missing port interfaces MUST be created in Domain for each adapter"
  #     -> "Vendor response types leaking into Domain MUST be replaced with domain DTOs"
  #     -> SOLID: DIP (complete the port-adapter chain)
  #   IF value == fully_isolated:
  #     -> (no corrective constraints, verify maintenance)
  #     -> Review: "Confirm no new vendor SDK types crossed layer boundaries"

# =============================================================================
# DIMENSION 5: CONCURRENCY MODEL
# =============================================================================
# How does this system handle concurrent operations?
# This determines performance optimization constraints.
concurrency_model:
  value: ""
  # Values:
  #   synchronous          - All operations sequential, no async capability
  #   async_capable        - Framework supports async but not fully utilized
  #   fully_concurrent     - Async/concurrent patterns actively used
  #   not_applicable       - No concurrent operations needed

  sequential_bottlenecks: []
  # Per-bottleneck detail:
  # sequential_bottlenecks:
  #   - location: "src/Application/Assembler/EditorialAssembler.php:45-78"
  #     calls_count: 5
  #     calls_independent: true   # Do calls depend on each other's results?
  #     estimated_impact: "sum of 5 HTTP call latencies"

  framework_async_support: ""     # e.g., "Symfony HttpClient stream()", "Promise.all()"

  evidence: []

  constraints: []
  # Constraint generation rules:
  #   IF value == synchronous AND data_source_topology.value in [multi_external, hybrid]:
  #     -> "Independent external API calls MUST be evaluated for concurrent execution"
  #     -> "Sequential HTTP calls to independent sources SHOULD be refactored to concurrent"
  #     -> SOLID: SRP (concurrency orchestration separated from data fetching)
  #   IF value == async_capable:
  #     -> "Evaluate whether sequential bottlenecks justify async migration"
  #     -> Review: "Verify no sequential calls to independent APIs exceed 3"
  #   IF value == fully_concurrent:
  #     -> "Concurrent operations MUST handle partial failures gracefully"
  #     -> "Timeout configuration MUST exist for all external HTTP calls"

# =============================================================================
# DIMENSION 6: RESPONSE CUSTOMIZATION NEEDS
# =============================================================================
# How much does the response need to vary per consumer or context?
# This determines serialization architecture.
response_customization:
  value: ""
  # Values:
  #   uniform              - Same response for all consumers
  #   parameterized        - Same structure, filtered fields (e.g., ?fields=id,name)
  #   per_consumer_shaped  - Different structure per consumer (mobile vs web)
  #   context_dependent    - Response varies by auth level, role, or feature flags

  evidence: []

  constraints: []
  # Constraint generation rules:
  #   IF value == uniform:
  #     -> (minimal constraints, single DTO sufficient)
  #   IF value == parameterized:
  #     -> "Field filtering MUST be handled in Application layer, not Domain"
  #     -> SOLID: SRP (domain doesn't know about field selection)
  #   IF value == per_consumer_shaped:
  #     -> "Each consumer MUST have a dedicated DTO or Transformer"
  #     -> "No switch/if-else by consumer type in serialization code"
  #     -> SOLID: SRP (one transformer per consumer), OCP (new consumer = new class)
  #   IF value == context_dependent:
  #     -> "Response shaping logic MUST be separated from business logic"
  #     -> "Context resolution MUST happen at the boundary (controller/middleware)"
  #     -> SOLID: SRP, OCP

# =============================================================================
# DERIVED CONSTRAINTS
# =============================================================================
# Constraints that emerge from the interaction of multiple dimensions.
# Generated by the diagnostic engine, not manually populated.
derived_constraints: []
# Derivation rules:
#
# IF data_source_topology in [multi_external, hybrid] AND dependency_isolation == direct_coupling:
#   -> CRITICAL: "Multiple external APIs with direct coupling creates cascading vendor risk"
#   -> "Each external source MUST be isolated behind Port + Adapter + ResponseMapper"
#   -> Corrective: AC-01 (Anti-Corruption Layer) in architecture-reference.md
#
# IF data_flow == aggregation AND concurrency_model == synchronous:
#   -> WARNING: "Aggregating multiple sources synchronously creates latency proportional to source count"
#   -> "Independent source fetches SHOULD use concurrent execution"
#   -> Corrective: AC-03 (Async HTTP Grouping) in architecture-reference.md
#
# IF consumer_diversity in [multi_platform, mixed] AND response_customization == per_consumer_shaped:
#   -> "Platform-specific response shaping MUST use Strategy or dedicated Transformers"
#   -> "Domain entities MUST remain consumer-agnostic"
#   -> Corrective: AC-04 (Multi-Platform Serialization) in architecture-reference.md
#
# IF data_flow == aggregation AND data_source_topology in [multi_external, hybrid]:
#   -> "Multi-source aggregation MUST use Assembler pattern with independent Providers"
#   -> Corrective: AC-02 (Data Assembler) in architecture-reference.md
#
# IF data_source_topology in [multi_external, hybrid] AND concurrency_model == synchronous:
#   -> "Performance bottleneck: N sequential HTTP calls = N * avg_latency response time"
#   -> "Evaluate framework async capabilities before designing assembly logic"

# =============================================================================
# CONSTRAINT SUMMARY
# =============================================================================
# Aggregated from all dimensions + derived, categorized by enforcement level.
constraint_summary:
  must: []             # Mandatory constraints (SOLID violations if not met)
  should: []           # Recommended constraints (quality/performance risk if not met)
  review_criteria: []  # What to verify during code review

# =============================================================================
# CORRECTIVE PATTERN MAPPING
# =============================================================================
# Maps active constraints to corrective patterns in architecture-reference.md.
# This is the bridge from "what must be true" to "how to make it true."
pattern_mapping: []
# Example:
# pattern_mapping:
#   - constraint: "External data sources MUST be accessed through abstraction boundaries"
#     pattern_ref: "AC-01: Anti-Corruption Layer"
#     reference_doc: "core/architecture-reference.md"
#   - constraint: "Multi-source assembly MUST be coordinated by a dedicated orchestrator"
#     pattern_ref: "AC-02: Complex Aggregate Data Assembly"
#     reference_doc: "core/architecture-reference.md"

# =============================================================================
# EXTRACTION METADATA
# =============================================================================
extracted_from: []          # Source files analyzed
extraction_method: ""       # automated | manual | hybrid
last_validated: ""          # ISO 8601 timestamp
