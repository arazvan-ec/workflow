# =============================================================================
# API Architecture Dimensional Profile
# =============================================================================
# Dimensional classification of a project's API architecture.
# This is a DETECTION artifact — it describes WHAT the architecture IS,
# not what it should be. It contains no constraints or prescriptions.
#
# Layer separation:
#   DISCOVER (Step 6c) → Classifies dimensions from code evidence (THIS FILE)
#   PLAN (Step 3.1b)   → Reasons about constraints from dimensions per-feature
#   REVIEW             → Validates constraints from design.md were satisfied
#
# Generated by: /workflows:discover (Step 6c)
# Consumed by:  /workflows:plan (Step 3.1b) — to generate feature-specific constraints
# Enriched by:  /workflows:compound (dimensional drift detection)
# Location:     openspec/specs/api-architecture-diagnostic.yaml
#
# Philosophy:
#   "The diagnostic describes reality. The planner reasons about constraints.
#    The constraint is the reasoning. The pattern is just the fix."
# =============================================================================

diagnostic_version: "2.0"
generated_at: ""                  # ISO 8601 timestamp
generated_by: "discover"          # discover | manual

# =============================================================================
# DIMENSION 1: DATA FLOW DIRECTION
# =============================================================================
# What direction does data move through this API system?
data_flow:
  primary: ""
  # Values:
  #   ingress         - External data comes IN to the system (consuming external APIs)
  #   egress          - Internal data goes OUT to consumers (serving API responses)
  #   aggregation     - Multiple external sources combined into domain objects
  #   transformation  - Data restructured between incompatible formats
  #   passthrough     - Data relayed with minimal transformation
  #   bidirectional   - Both ingress and egress are significant
  secondary: []                   # Other flows present (same value set)

  # Detection heuristics (stack-agnostic):
  #   ingress:       HTTP client libs in codebase, external API adapters
  #   egress:        Controllers/handlers serving JSON/XML, serializers
  #   aggregation:   Services combining 3+ data sources into one response
  #   transformation: Mapper/transformer classes, DTO conversions
  #   passthrough:   Proxy routes, gateway patterns, minimal logic
  #   bidirectional: Both HTTP client usage AND controller endpoints present

  evidence: []
  # Example:
  # evidence:
  #   - "src/Infrastructure/External/ contains 4 API adapters (ingress)"
  #   - "src/Infrastructure/Controller/ serves 12 endpoints (egress)"

# =============================================================================
# DIMENSION 2: DATA SOURCE TOPOLOGY
# =============================================================================
# Where does this system's data come from?
data_source_topology:
  value: ""
  # Values:
  #   single_db            - One primary database, no external APIs
  #   multi_db             - Multiple databases (read replicas, sharding, polyglot)
  #   single_external      - One external API/SDK consumed
  #   multi_external       - Multiple external APIs/SDKs consumed
  #   mixed_db_external    - Database(s) + external API(s) combined
  #   event_driven         - Primary data from message queues/event streams
  #   hybrid               - Mix of databases, APIs, and events

  external_sources: []
  # Per-source detail:
  # external_sources:
  #   - name: "Content Management API"
  #     sdk_or_client: "vendor/cms-sdk"
  #     isolation_status: "isolated"    # isolated | partially_wrapped | direct_coupling
  #     port_interface: "src/Domain/Port/ContentProviderInterface.php"
  #     adapter: "src/Infrastructure/External/CmsAdapter.php"

  evidence: []

# =============================================================================
# DIMENSION 3: CONSUMER DIVERSITY
# =============================================================================
# Who consumes this system's output?
consumer_diversity:
  value: ""
  # Values:
  #   single_consumer         - One client (e.g., one web app)
  #   multi_platform          - Multiple client types (web, mobile, desktop)
  #   inter_service           - Other microservices consume this API
  #   public_api              - Third-party developers consume this API
  #   mixed                   - Combination of the above

  consumers: []
  # Per-consumer detail:
  # consumers:
  #   - name: "Mobile App (iOS/Android)"
  #     format: "compact JSON"
  #     special_needs: "minimal payload, image URLs only"
  #   - name: "Web Dashboard"
  #     format: "full JSON"
  #     special_needs: "includes relationships, pagination"

  evidence: []

# =============================================================================
# DIMENSION 4: DEPENDENCY ISOLATION LEVEL
# =============================================================================
# How well are external dependencies isolated from the domain?
dependency_isolation:
  value: ""
  # Values:
  #   fully_isolated      - All externals behind ports + adapters + mappers
  #   partially_wrapped   - Some adapters exist but ports or mappers are missing
  #   direct_coupling     - External SDKs used directly in Application/Domain
  #   no_externals        - No external dependencies to isolate

  violations: []
  # Per-violation detail:
  # violations:
  #   - location: "src/Application/Service/EditorialService.php:23"
  #     external: "GuzzleHttp\\Client"
  #     layer: "Application"
  #     severity: "high"          # high = in Domain, medium = in Application

  evidence: []

# =============================================================================
# DIMENSION 5: CONCURRENCY MODEL
# =============================================================================
# How does this system handle concurrent operations?
concurrency_model:
  value: ""
  # Values:
  #   synchronous          - All operations sequential, no async capability
  #   async_capable        - Framework supports async but not fully utilized
  #   fully_concurrent     - Async/concurrent patterns actively used
  #   not_applicable       - No concurrent operations needed

  sequential_bottlenecks: []
  # Per-bottleneck detail:
  # sequential_bottlenecks:
  #   - location: "src/Application/Assembler/EditorialAssembler.php:45-78"
  #     calls_count: 5
  #     calls_independent: true   # Do calls depend on each other's results?
  #     estimated_impact: "sum of 5 HTTP call latencies"

  framework_async_support: ""     # e.g., "Symfony HttpClient stream()", "Promise.all()"

  evidence: []

# =============================================================================
# DIMENSION 6: RESPONSE CUSTOMIZATION NEEDS
# =============================================================================
# How much does the response need to vary per consumer or context?
response_customization:
  value: ""
  # Values:
  #   uniform              - Same response for all consumers
  #   parameterized        - Same structure, filtered fields (e.g., ?fields=id,name)
  #   per_consumer_shaped  - Different structure per consumer (mobile vs web)
  #   context_dependent    - Response varies by auth level, role, or feature flags

  evidence: []

# =============================================================================
# EXTRACTION METADATA
# =============================================================================
extracted_from: []          # Source files analyzed
extraction_method: ""       # automated | manual | hybrid
last_validated: ""          # ISO 8601 timestamp
